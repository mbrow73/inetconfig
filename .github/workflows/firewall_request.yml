name: üîí Process Firewall Requests

concurrency:
  group: firewall-requests
  cancel-in-progress: false

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues:   write
  pull-requests: write

jobs:
  process:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'firewall-request')

    steps:
      # 1Ô∏è‚É£ Check out the repo
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # 2Ô∏è‚É£ Parse the Issue into JSON
      - name: üìù Parse issue into JSON (and CARID)
        id: parse
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const body = context.payload.issue.body || "";
            if (!body) throw new Error("No issue body found");
            const req = body.match(/REQ\d+/);
            if (!req) throw new Error("Missing Request ID (REQID)");
            const request_id_reqid = req[0];
            const car = body.match(/CARID\s*[:\-]\s*(\S+)/i);
            if (!car) throw new Error("Missing CARID");
            const carid = car[1];
            const lines = body.split(/\r?\n/), rules = [];
            let cur = null;
            for (const raw of lines) {
              const l = raw.trim();
              if (/^(?:#+\s*)?Rule\s*\d+/i.test(l)) {
                if (cur) rules.push(cur);
                cur = { request_id_reqid };
                continue;
              }
              if (!cur) continue;
              const m = l.match(/^üîπ\s*(.+?)\s*:\s*(.+)$/);
              if (m) {
                const k = m[1].toLowerCase().replace(/[^a-z0-9]+/g,"_").replace(/_+$/,"");
                const v = m[2].trim().replace(/^`|`$/g,"");
                cur[k] = v;
              }
            }
            if (cur) rules.push(cur);
            if (!rules.length) throw new Error("No rules found in issue body");
            return JSON.stringify({ carid, request_id_reqid, rules });

      # 3Ô∏è‚É£ Persist parsed JSON
      - name: üíæ Save parsed JSON
        run: echo '${{ steps.parse.outputs.result }}' > parsed.json

      # 4Ô∏è‚É£ Pull in latest main (so we see existing requests)
      - name: üîÑ Merge latest main
        run: |
          git fetch origin main
          git merge origin/main --strategy-option theirs

      # 5Ô∏è‚É£ Consolidated validation
      - name: ‚úÖ Run validation
        id: validate
        continue-on-error: true
        shell: bash
        run: |
          set -uo pipefail
          > validation.log
          # validate_firewall_requests.py reads parsed.json + all existing rules
          python3 scripts/validate_firewall_requests.py parsed.json 2>&1 | tee validation.log || true
          if grep -q '^‚ùå' validation.log; then
            echo "exit_code=1" >> $GITHUB_OUTPUT
          else
            echo "exit_code=0" >> $GITHUB_OUTPUT
          fi

      # 6Ô∏è‚É£ Comment & close on validation failure
      - name: üí¨ Comment on validation failure
        if: steps.validate.outputs.exit_code != '0'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const errs = require('fs').readFileSync('validation.log','utf8');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `‚ö†Ô∏è **Validation failed**:\n\`\`\`\n${errs}\n\`\`\`\nPlease fix and reopen.`
            });

      - name: üõë Close Issue on validation failure
        if: steps.validate.outputs.exit_code != '0'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              state: 'closed'
            });

      - name: ‚è≠Ô∏è Skip remaining steps on validation failure
        if: steps.validate.outputs.exit_code != '0'
        run: echo "Skipping inject & PR steps."

      # 7Ô∏è‚É£ Build PR body
      - name: ‚ú® Build PR body
        if: steps.validate.outputs.exit_code == '0'
        id: build_pr_body
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const p = JSON.parse(`\${{ steps.parse.outputs.result }}`);
            const lines = p.rules.map((r,i) =>
              `- Rule ${i+1}: ${r.source_ip_s_or_cidr_s} ‚Üí ${r.destination_ip_s_or_cidr_s} on ${r.protocol}/${r.port_s}\n  Justification: ${r.business_justification}`
            ).join("\n");
            return `Auto-generated firewall requests **${p.request_id_reqid}**:\n\n${lines}\n\nCloses #${{ github.event.issue.number }}`;

      # 8Ô∏è‚É£ Assign priorities & write per-request JSON
      - name: ‚úçÔ∏è Assign priorities & write per-request JSON
        if: steps.validate.outputs.exit_code == '0'
        run: |
          mkdir -p firewall_requests
          python3 - << 'EOF'
          import json, glob
          from pathlib import Path

          parsed = json.load(open("parsed.json"))

          prios = set()
          try:
              man = json.load(open("manual.auto.tfvars.json"))
              prios |= {r.get("priority",0) for r in man.get("manual_firewall_rules", [])}
          except FileNotFoundError:
              pass
          for fn in glob.glob("firewall_requests/*.json"):
              data = json.load(open(fn))
              prios |= {r.get("priority",0) for r in data.get("rules", [])}

          next_prio = max(prios) + 1 if prios else 1001
          out = {"carid": parsed["carid"], "request_id_reqid": parsed["request_id_reqid"], "rules": []}
          for rule in parsed["rules"]:
              rule["priority"] = next_prio
              next_prio += 1
              out["rules"].append(rule)

          fn = f"firewall_requests/{parsed['request_id_reqid']}.json"
          Path(fn).write_text(json.dumps(out, indent=2))
          print(f"Wrote {fn} with priorities {[r['priority'] for r in out['rules']]}")

          EOF

      # 9Ô∏è‚É£ Setup Terraform for fmt & validate
      - name: ‚öôÔ∏è Setup Terraform
        if: steps.validate.outputs.exit_code == '0'
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.5.0'

      # üîü Terraform fmt & validate
      - name: üßπ Terraform fmt & validate
        if: steps.validate.outputs.exit_code == '0'
        env:
          TF_IN_AUTOMATION: true
        run: |
          terraform init -backend=false
          terraform fmt -recursive
          terraform validate

      # 1Ô∏è‚É£1Ô∏è‚É£ Cleanup generated files
      - name: üßπ Cleanup generated files
        if: steps.validate.outputs.exit_code == '0'
        run: |
          git rm -rf .terraform .terraform.lock.hcl || true
          git rm -f parsed.json validation.log || true

      # 1Ô∏è‚É£2Ô∏è‚É£ Create PR for NetSec review
      - name: üîÄ Create PR for NetSec review
        if: steps.validate.outputs.exit_code == '0'
        uses: peter-evans/create-pull-request@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: firewall-req-${{ fromJson(steps.parse.outputs.result).request_id_reqid }}
          title: "[Firewall] ${{ fromJson(steps.parse.outputs.result).request_id_reqid }} ‚Äì ${{ fromJson(steps.parse.outputs.result).rules[0].protocol }}/${{ fromJson(steps.parse.outputs.result).rules[0].port_s }}"
          labels: firewall-rule,pending-review
          body: ${{ steps.build_pr_body.outputs.result }}

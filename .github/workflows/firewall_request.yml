name: 🔒 Process Firewall Requests

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'firewall-request')

    steps:
      # 1️⃣ Check out the repository
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # 2️⃣ Parse the Issue Form response into rule objects
      - name: 📝 Parse issue form into JSON
        id: parse
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const body = context.payload.issue.body;
            
            // Request ID is typically under "Request ID (REQID)"
            const reqIdMatch = body.match(/Request ID.*?\n(.+)/i);
            const request_id = reqIdMatch ? reqIdMatch[1].trim().replace(/`/g,'') : '';
            if (!request_id) throw new Error("Empty Request ID");

            // Optional: Overall justification (not used per rule but can store)
            const justificationMatch = body.match(/Overall Business Justification.*?\n(.+)/i);
            const overall_justification = justificationMatch ? justificationMatch[1].trim() : '';

            // Parse each rule block from textarea "Rules"
            const rulesSection = body.split(/### Rules/i)[1];
            if (!rulesSection) throw new Error("No rules section found");
            // split on blank lines between rules
            const ruleBlocks = rulesSection.split(/\n\s*\n/).filter(r => r.match(/Source:/i));

            const rules = ruleBlocks.map((block, i) => {
              const lines = block.split('\n').map(l => l.trim()).filter(Boolean);
              const rule = {
                request_id: `${request_id}-${i+1}`
              };
              for (const line of lines) {
                if (line.match(/^Source:/i))
                  rule.source_ip_s_or_cidr_s = line.replace(/Source:/i, '').replace(/`/g,'').trim();
                if (line.match(/^Destination:/i))
                  rule.destination_ip_s_or_cidr_s = line.replace(/Destination:/i, '').replace(/`/g,'').trim();
                if (line.match(/^Ports:/i))
                  rule.port_s = line.replace(/Ports:/i, '').replace(/`/g,'').trim();
                if (line.match(/^Protocol:/i))
                  rule.protocol = line.replace(/Protocol:/i, '').replace(/`/g,'').trim();
                if (line.match(/^Direction:/i))
                  rule.direction = line.replace(/Direction:/i, '').replace(/`/g,'').trim();
                if (line.match(/^Justification:/i))
                  rule.business_justification = line.replace(/Justification:/i, '').replace(/`/g,'').trim();
              }
              return rule;
            });

            return JSON.stringify({ request_id, overall_justification, rules });

      # 3️⃣ Persist the parsed payload to disk
      - name: 💾 Save parsed JSON
        run: echo '${{ steps.parse.outputs.result }}' > parsed.json

      # 4️⃣ Run validation on each rule (job won’t abort here)
      - name: ✅ Run validation
        id: validate
        continue-on-error: true
        run: |
          set -o pipefail
          exit_code=0
          > validation.log
          while IFS= read -r rule; do
            echo "Validating rule: $rule" | tee -a validation.log
            python3 scripts/validate_firewall_request.py "$rule" 2>&1 | tee -a validation.log || exit_code=1
          done < <(jq -c '.rules[]' parsed.json)
          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT
        shell: bash

      # 5️⃣ If validation failed, comment back to the Issue
      - name: 💬 Comment on validation failure
        if: steps.validate.outputs.exit_code != '0'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const errs = require('fs').readFileSync('validation.log','utf8');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `⚠️ **Validation failed** for your firewall request:\n\`\`\`\n${errs}\n\`\`\`\nPlease correct and re-open this issue when ready.`
            });

      # 6️⃣ Skip the rest if validation failed
      - name: ⏭️ Skip remaining steps on validation error
        if: steps.validate.outputs.exit_code != '0'
        run: echo "Validation errors detected; skipping Terraform & PR steps."

      # 7️⃣ Build the PR body (only on success)
      - name: ✨ Build PR body
        if: steps.validate.outputs.exit_code == '0'
        id: build_pr_body
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const parsed = JSON.parse(require('fs').readFileSync('parsed.json','utf8'));
            const lines = parsed.rules
              .map((r,i) => `- Rule ${i+1}: ${r.source_ip_s_or_cidr_s} → ${r.destination_ip_s_or_cidr_s} on ${r.protocol}/${r.port_s}`)
              .join("\n");
            return `Auto-generated firewall rules for **${parsed.request_id}**:\n\n${lines}\n\nCloses #${{ github.event.issue.number }}`;

      # 8️⃣ Setup Terraform (only on success)
      - name: ⚙️ Setup Terraform
        if: steps.validate.outputs.exit_code == '0'
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.5.0'

      # 9️⃣ Inject rules into your tfvars file (only on success)
      - name: ✍️ Inject rules into tfvars
        if: steps.validate.outputs.exit_code == '0'
        run: |
          python3 scripts/add_firewall_rule.py "$(cat parsed.json)" e1inetpolicy.auto.tfvars.json

      # 🔟 Terraform fmt & validate (only on success)
      - name: 🧹 Terraform fmt & validate
        if: steps.validate.outputs.exit_code == '0'
        env:
          TF_IN_AUTOMATION: true
        run: |
          terraform init -backend=false
          terraform fmt -recursive
          terraform validate

      # 1️⃣1️⃣ Cleanup Terraform runtime files (only on success)
      - name: 🗑️ Cleanup Terraform runtime files
        if: steps.validate.outputs.exit_code == '0'
        run: rm -rf .terraform .terraform.lock.hcl

      # 1️⃣2️⃣ Create Pull Request for NetSec review (only on success)
      - name: 🔀 Create PR for NetSec review
        if: steps.validate.outputs.exit_code == '0'
        uses: peter-evans/create-pull-request@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: firewall-req-${{ fromJson(steps.parse.outputs.result).request_id }}
          title: "[Firewall] ${{ fromJson(steps.parse.outputs.result).request_id }}"
          labels: firewall-rule,pending-review
          body: ${{ steps.build_pr_body.outputs.result }}

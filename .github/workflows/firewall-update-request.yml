name: üîÑ Process Firewall Rule Updates

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    if: contains(github.event.issue.labels.*.name, 'firewall-update-request')
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üîç Parse Issue and Update Rules
        id: updater
        shell: bash
        run: |
          set -e
          set -x

          ISSUE_BODY="${{ github.event.issue.body }}"

          # Extract top-level REQID and CARID
          REQID=$(echo "$ISSUE_BODY" | grep -i "Request ID" | head -1 | awk -F: '{print $2}' | xargs)
          CARID=$(echo "$ISSUE_BODY" | grep -i "CARID" | head -1 | awk -F: '{print $2}' | xargs)
          if [ -z "$REQID" ] || [ -z "$CARID" ]; then
            echo "Request ID and CARID required."
            exit 1
          fi

          # Split each rule block (identified by 'Existing Rule Name')
          echo "$ISSUE_BODY" | awk '/^Existing Rule Name:/ {if(rule) print rule; rule="";} {rule = rule $0 "\n"} END{print rule}' | grep -v '^$' > rule_blocks.txt

          mkdir -p firewall-requests-updated
          cp -r firewall-requests/* firewall-requests-updated/ 2>/dev/null || true

          while IFS= read -r ruleblock; do
            [ -z "$ruleblock" ] && continue
            EXISTING=$(echo "$ruleblock" | grep "Existing Rule Name:" | awk -F: '{print $2}' | xargs)
            SRC=$(echo "$ruleblock" | grep "New Source IP(s):" | awk -F: '{print $2}' | xargs)
            DST=$(echo "$ruleblock" | grep "New Destination IP(s):" | awk -F: '{print $2}' | xargs)
            PORTS=$(echo "$ruleblock" | grep "New Port(s):" | awk -F: '{print $2}' | xargs)
            PROTO=$(echo "$ruleblock" | grep "New Protocol:" | awk -F: '{print $2}' | xargs)
            DIR=$(echo "$ruleblock" | grep "New Direction:" | awk -F: '{print $2}' | xargs)
            JUST=$(echo "$ruleblock" | grep "New Business Justification:" | awk -F: '{print $2}' | xargs)

            # Find the file containing this rule
            FILE=""
            for f in firewall-requests-updated/**/*.auto.tfvars.json firewall-requests-updated/*.auto.tfvars.json; do
              if [ -f "$f" ] && jq -e --arg name "$EXISTING" '.auto_firewall_rules[] | select(.name==$name)' "$f" >/dev/null; then
                FILE="$f"
                break
              fi
            done
            if [ -z "$FILE" ]; then
              echo "Rule $EXISTING not found."
              continue
            fi

            # Extract original REQID from rule name
            ORIG_REQID=$(echo "$EXISTING" | awk -F- '{print $2}')
            NEW_RULENAME="$EXISTING"

            if [ "$REQID" = "$ORIG_REQID" ]; then
              # --- UPDATE IN PLACE ---
              # Only update fields, leave rulename and file unchanged.
              jq '(.auto_firewall_rules[] | select(.name=="'"$EXISTING"'") | .src_ip_ranges) |= (['"\"$SRC\""'"] | map(select(. != "")))' "$FILE" > "$FILE.tmp"
              mv "$FILE.tmp" "$FILE"
              jq '(.auto_firewall_rules[] | select(.name=="'"$EXISTING"'") | .dest_ip_ranges) |= (['"\"$DST\""'"] | map(select(. != "")))' "$FILE" > "$FILE.tmp"
              mv "$FILE.tmp" "$FILE"
              jq '(.auto_firewall_rules[] | select(.name=="'"$EXISTING"'") | .ports) |= (['"\"$PORTS\""'"] | map(select(. != "")))' "$FILE" > "$FILE.tmp"
              mv "$FILE.tmp" "$FILE"
              [ -n "$PROTO" ] && jq '(.auto_firewall_rules[] | select(.name=="'"$EXISTING"'") | .protocol) |= "'"$PROTO"'"' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
              [ -n "$DIR" ] && jq '(.auto_firewall_rules[] | select(.name=="'"$EXISTING"'") | .direction) |= "'"$DIR"'"' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
              [ -n "$JUST" ] && jq '(.auto_firewall_rules[] | select(.name=="'"$EXISTING"'") | .description) |= "'"$JUST"'"' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
              echo "Rule $EXISTING updated in place."
            else
              # --- MOVE TO NEW FILE/REQID + RENAME ---
              # Change REQID in rule name, remove from old file, add to new file with updated fields.
              NEW_RULENAME=$(echo "$EXISTING" | sed "s/$ORIG_REQID/$REQID/")
              # Build new nested path: firewall-requests-updated/REQ_ORIG/REQID/REQID.auto.tfvars.json
              NESTED="firewall-requests-updated/$ORIG_REQID/$REQID"
              mkdir -p "$NESTED"
              NEWFILE="$NESTED/$REQID.auto.tfvars.json"
              # If new file doesn't exist, create base
              [ ! -f "$NEWFILE" ] && echo '{"auto_firewall_rules":[]}' > "$NEWFILE"
              # Get original rule and apply changes
              rule_json=$(jq '.auto_firewall_rules[] | select(.name=="'"$EXISTING"'")' "$FILE")
              [ -n "$SRC" ] && rule_json=$(echo "$rule_json" | jq '.src_ip_ranges = ["'"$SRC"'"]')
              [ -n "$DST" ] && rule_json=$(echo "$rule_json" | jq '.dest_ip_ranges = ["'"$DST"'"]')
              [ -n "$PORTS" ] && rule_json=$(echo "$rule_json" | jq '.ports = ["'"$PORTS"'"]')
              [ -n "$PROTO" ] && rule_json=$(echo "$rule_json" | jq '.protocol = "'"$PROTO"'"')
              [ -n "$DIR" ] && rule_json=$(echo "$rule_json" | jq '.direction = "'"$DIR"'"')
              [ -n "$JUST" ] && rule_json=$(echo "$rule_json" | jq '.description = "'"$JUST"'"')
              rule_json=$(echo "$rule_json" | jq '.name = "'"$NEW_RULENAME"'"')
              # Remove from old file
              jq 'del(.auto_firewall_rules[] | select(.name == "'"$EXISTING"'"))' "$FILE" > "$FILE.tmp"
              mv "$FILE.tmp" "$FILE"
              # Add to new file
              tmpfile=$(mktemp)
              jq --argjson rule "$rule_json" '.auto_firewall_rules += [$rule]' "$NEWFILE" > "$tmpfile"
              mv "$tmpfile" "$NEWFILE"
              echo "Rule moved and updated: $EXISTING -> $NEWFILE ($NEW_RULENAME)"
            fi

          done < <(cat rule_blocks.txt)

          cp -r firewall-requests-updated/* firewall-requests/

          echo "=== FILES AFTER ==="
          find firewall-requests -type f -name '*.auto.tfvars.json' | while read -r f; do
            echo "----- $f -----"
            cat "$f"
          done

          echo "REQID=$REQID" >> $GITHUB_ENV

      - name: ‚è´ Create or Update Pull Request for NetSec
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: |
            [Firewall Automation] Update rules for ${{ env.REQID }}
          branch: firewall/${{ env.REQID }}-update-${{ github.event.issue.number }}
          title: "Firewall update: ${{ env.REQID }} (Issue #${{ github.event.issue.number }})"
          body: |
            Automated firewall rule update for REQID `${{ env.REQID }}`.

            **Source:** ${{ github.event.issue.user.login }}
            **Related Issue:** #${{ github.event.issue.number }}

            See new file(s) in `firewall-requests/`.
          add-paths: |
            firewall-requests/**/*.auto.tfvars.json
            firewall-requests/*.auto.tfvars.json
          base: main

      - name: üí¨ Comment PR Link to Issue
        if: steps.cpr.outputs.pull-request-url != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `:robot: PR [#${{ steps.cpr.outputs.pull-request-number }}](${{ steps.cpr.outputs.pull-request-url }}) opened/updated for NetSec review.`
            })

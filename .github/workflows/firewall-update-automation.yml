name: üîÑ Firewall Rule Update/Removal Requests

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    if: contains(github.event.issue.labels.*.name, 'firewall-update-request')
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üìù Parse Issue for Update/Remove/Move, Modify JSON
        id: parse_and_update
        shell: bash
        run: |
          set -e
          set -x

          ISSUE_BODY="${{ github.event.issue.body }}"
          # Remove markdown instructions for clean parsing
          ISSUE_BODY_CLEAN=$(echo "$ISSUE_BODY" | sed '/<!--/,/-->/d')

          # Prepare scratch for touched REQIDs
          touch reqids_touched.txt

          # Parse each rule block
          echo "$ISSUE_BODY_CLEAN" | awk '
            BEGIN{rule=0}
            /^#### Rule/{
              if(rule){
                print rule_block "\n@@@"
              }
              rule_block = ""
              rule=1
              next
            }
            {
              if(rule){
                rule_block = rule_block $0 "\n"
              }
            }
            END{
              if(rule){
                print rule_block
              }
            }
          ' > all_rules.txt

          # Process each rule instruction
          awk 'BEGIN{RS="@@@"} NR>0 && NF{print > ("rule_" NR ".txt")}' all_rules.txt

          for f in rule_*.txt; do
            rulename=""
            action=""
            newreqid=""
            src=""
            dst=""
            ports=""
            proto=""
            dir=""
            just=""
            while IFS= read -r line; do
              case "$line" in
                *"Existing Rule Name:"*) rulename=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"Action:"*) action=$(echo "$line" | cut -d: -f2- | xargs | tr '[:upper:]' '[:lower:]') ;;
                *"New REQID:"*) newreqid=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"New Source"*) src=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"New Destination"*) dst=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"New Port"*) ports=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"New Protocol"*) proto=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"New Direction"*) dir=$(echo "$line" | cut -d: -f2- | xargs) ;;
                *"New Business Justification"*) just=$(echo "$line" | cut -d: -f2- | xargs) ;;
              esac
            done < "$f"

            # Extract REQID, CARID, etc. from the existing rule name
            oldreqid=$(echo "$rulename" | awk -F'-' '{print $2}')
            carid=$(echo "$rulename" | awk -F'-' '{print $3}')
            proto_part=$(echo "$rulename" | awk -F'-' '{print $(NF-2)}')
            port_part=$(echo "$rulename" | awk -F'-' '{print $(NF-1)}')
            rule_number=$(echo "$rulename" | awk -F'-' '{print $NF}')
            [ -z "$newreqid" ] && newreqid="$oldreqid"
            new_name="AUTO-${newreqid}-${carid}-${proto_part}-${port_part}-${rule_number}"

            # Paths
            old_json="firewall-requests/${oldreqid}.auto.tfvars.json"
            new_json="firewall-requests/${newreqid}.auto.tfvars.json"

            # Ensure old_json exists
            if [ ! -f "$old_json" ]; then
              echo "::warning file=$old_json::Could not find source tfvars file for $rulename. Skipping."
              continue
            fi

            # Load old rules
            cp "$old_json" "${old_json}.bak"
            jq '.auto_firewall_rules' "$old_json" > rules_in_file.json

            # Remove rule from old file if moving/removing
            if [ "$action" = "remove" ] || ([ "$action" = "move" ] && [ "$newreqid" != "$oldreqid" ]); then
              jq "map(select(.name != \"$rulename\"))" rules_in_file.json > new_rules.json
              jq '{auto_firewall_rules: .}' new_rules.json > "$old_json"
              echo "$oldreqid" >> reqids_touched.txt
            fi

            # Add or update rule in new file if updating or moving
            if [ "$action" = "update" ] || [ "$action" = "move" ]; then
              # Create new file if needed
              [ -f "$new_json" ] || echo '{"auto_firewall_rules":[]}' > "$new_json"
              # Remove old rule from new file if present (avoid dupes)
              jq '.auto_firewall_rules' "$new_json" | jq "map(select(.name != \"$rulename\"))" > rules_temp.json

              # Build update expression
              update_expr=". + {"
              [ -n "$src" ] && update_expr="${update_expr}src_ip_ranges: [\"$src\"],"
              [ -n "$dst" ] && update_expr="${update_expr}dest_ip_ranges: [\"$dst\"],"
              [ -n "$ports" ] && update_expr="${update_expr}ports: [\"$ports\"],"
              [ -n "$proto" ] && update_expr="${update_expr}protocol: \"$proto\","
              [ -n "$dir" ] && update_expr="${update_expr}direction: \"$dir\","
              [ -n "$just" ] && update_expr="${update_expr}description: \"$just\","
              update_expr="${update_expr%,}}"

              # Build new rule JSON (merge with old fields, then update fields)
              old_rule=$(jq -c ".[] | select(.name == \"$rulename\")" rules_in_file.json)
              if [ -z "$old_rule" ]; then
                echo "::warning::Could not find rule $rulename in $old_json. Skipping."
                continue
              fi
              new_rule=$(echo "$old_rule" | jq "$update_expr" | jq ".name = \"$new_name\"")

              # Append to new file's rules
              jq ". + [$new_rule]" rules_temp.json > rules_updated.json
              jq '{auto_firewall_rules: .}' rules_updated.json > "$new_json"
              echo "$newreqid" >> reqids_touched.txt
            fi

          done

          # Remove duplicate REQIDs touched
          sort -u reqids_touched.txt > reqids_unique.txt

          # For PR step, set env
          echo "REQIDS=$(paste -sd, reqids_unique.txt)" >> $GITHUB_ENV

      - name: ‚è´ Create or Update Pull Request for NetSec
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: |
            [Firewall Automation] Update/remove/move rules for ${{ env.REQIDS }}
          branch: firewall/${{ env.REQIDS }}-update-${{ github.event.issue.number }}
          title: "Firewall update/removal: ${{ env.REQIDS }} (Issue #${{ github.event.issue.number }})"
          body: |
            Automated firewall rule update/removal/move for REQID(s): `${{ env.REQIDS }}`.

            **Summary:**
            - Source: ${{ github.event.issue.user.login }}
            - Related Issue: #${{ github.event.issue.number }}

            **Rules:**  
            _See the affected file(s) in `firewall-requests/` for full details._

            > **NetSec:** Please review and merge if approved.  
          add-paths: |
            firewall-requests/*.auto.tfvars.json
          base: main

      - name: üí¨ Comment PR Link to Issue
        if: steps.cpr.outputs.pull-request-url != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `:robot: PR [#${{ steps.cpr.outputs.pull-request-number }}](${{ steps.cpr.outputs.pull-request-url }}) opened/updated for NetSec review.`
            })

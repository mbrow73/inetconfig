name: üîÑ Process Firewall Rule Update/Removal Requests

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    if: contains(github.event.issue.labels.*.name, 'firewall-update-request')
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üìù Parse Issue and Update/Move/Remove Rules
        id: process
        shell: bash
        run: |
          set -e
          set -x

          # 1. Clean out any instructions between <!-- and -->
          ISSUE_BODY="${{ github.event.issue.body }}"
          ISSUE_BODY_CLEAN=$(echo "$ISSUE_BODY" | sed '/<!--/,/-->/d')

          echo "=== CLEANED ISSUE BODY ==="
          echo "$ISSUE_BODY_CLEAN"

          # 2. Parse out new REQID and CARID
          REQID=$(echo "$ISSUE_BODY_CLEAN" | grep -i "Request ID" | head -1 | cut -d: -f2- | xargs)
          CARID=$(echo "$ISSUE_BODY_CLEAN" | grep -i "CARID" | head -1 | cut -d: -f2- | xargs)
          echo "REQID: $REQID"
          echo "CARID: $CARID"
          if [ -z "$REQID" ]; then echo "REQID not found"; exit 1; fi
          if [ -z "$CARID" ]; then echo "CARID not found"; exit 1; fi

          # 3. Parse all rules - split with @@@ so we can loop over each rule
          RULES=$(echo "$ISSUE_BODY_CLEAN" | awk '
            BEGIN{rule=0}
            /^#### Rule/{
              if(rule){
                print rule_block "@@@"
              }
              rule_block = ""
              rule=1
              next
            }
            {
              if(rule){
                rule_block = rule_block $0 "\n"
              }
            }
            END{
              if(rule){
                print rule_block "@@@"
              }
            }
          ')
          echo "=== RULES PARSED ==="
          echo "$RULES"

          # 4. Parse update instructions, one per rule
          echo "$RULES" | awk -v RS="@@@" '
            BEGIN{FS=": ";OFS=": ";}
            function trim(s) {gsub(/^[ \t]+|[ \t]+$/, "", s); return s;}
            {
              rulename=action=src=dst=ports=proto=dir=just=""
              for(i=1;i<=NF;i++) {
                if ($i ~ /Existing Rule Name/) rulename=trim($(i+1))
                else if ($i ~ /Action/) action=trim($(i+1))
                else if ($i ~ /New Source/) src=trim($(i+1))
                else if ($i ~ /New Destination/) dst=trim($(i+1))
                else if ($i ~ /New Port/) ports=trim($(i+1))
                else if ($i ~ /New Protocol/) proto=trim($(i+1))
                else if ($i ~ /New Direction/) dir=trim($(i+1))
                else if ($i ~ /New Business Justification/) just=trim($(i+1))
              }
              if(rulename && action) print rulename "|" action "|" src "|" dst "|" ports "|" proto "|" dir "|" just
            }
          ' | grep . > update_instructions.txt

          echo "=== UPDATE INSTRUCTIONS ==="
          cat update_instructions.txt

          # 5. For each rule, find the file, update/move/remove as needed
          shopt -s nullglob

          declare -A rule_to_file
          for f in firewall-requests/*.auto.tfvars.json; do
            while read -r rulename; do
              rule_to_file["$rulename"]="$f"
            done < <(jq -r '.auto_firewall_rules[].name' "$f")
          done

          mkdir -p firewall-requests-updated
          cp firewall-requests/*.auto.tfvars.json firewall-requests-updated/ 2>/dev/null || true

          declare -A touched_files

          while IFS= read -r inst; do
            IFS='|' read -r existing_rulename action src dst ports proto dir just <<< "$inst"
            existing_rulename=$(echo "$existing_rulename" | xargs)
            action=$(echo "$action" | xargs)
            src=$(echo "$src" | xargs)
            dst=$(echo "$dst" | xargs)
            ports=$(echo "$ports" | xargs)
            proto=$(echo "$proto" | xargs)
            dir=$(echo "$dir" | xargs)
            just=$(echo "$just" | xargs)
            echo "---"
            echo "Processing: $existing_rulename | $action"

            old_file="${rule_to_file[$existing_rulename]}"
            if [ -z "$old_file" ]; then
              echo "Rule $existing_rulename not found in any file, skipping"
              continue
            fi

            touched_files["$old_file"]=1

            # Remove the rule from the original file (even if we're just updating/moving)
            jq 'del(.auto_firewall_rules[] | select(.name == "'"$existing_rulename"'"))' "$old_file" > "firewall-requests-updated/$(basename "$old_file")"

            # If remove, done!
            if [ "$action" = "remove" ]; then
              echo "Removed $existing_rulename from $old_file"
              continue
            fi

            # Otherwise, move or update (add to new file)
            rule_obj=$(jq -c --arg name "$existing_rulename" '.auto_firewall_rules[] | select(.name==$name)' "$old_file")
            if [ -z "$rule_obj" ]; then
              echo "Rule object not found for $existing_rulename in $old_file"
              continue
            fi

            old_reqid=$(echo "$existing_rulename" | awk -F- '{print $2}')

            new_rulename=$existing_rulename
            if [ "$REQID" != "$old_reqid" ]; then
              new_rulename=$(echo "$existing_rulename" | sed "s/$old_reqid/$REQID/")
              new_file="firewall-requests-updated/${REQID}.auto.tfvars.json"
            else
              new_file="firewall-requests-updated/$(basename "$old_file")"
            fi

            # Add updated/moved rule to new file
            if [ ! -f "$new_file" ]; then
              echo '{"auto_firewall_rules": []}' > "$new_file"
            fi

            # Build the new rule object (update fields if provided)
            new_rule=$(echo "$rule_obj" | jq '.name = "'$new_rulename'"')
            [ -n "$src" ]  && new_rule=$(echo "$new_rule" | jq '.src_ip_ranges = ["'"$src"'"]')
            [ -n "$dst" ]  && new_rule=$(echo "$new_rule" | jq '.dest_ip_ranges = ["'"$dst"'"]')
            [ -n "$ports" ] && new_rule=$(echo "$new_rule" | jq '.ports = ["'"$ports"'"]')
            [ -n "$proto" ] && new_rule=$(echo "$new_rule" | jq '.protocol = "'"$proto"'"')
            [ -n "$dir" ]   && new_rule=$(echo "$new_rule" | jq '.direction = "'"$dir"'"')
            [ -n "$just" ]  && new_rule=$(echo "$new_rule" | jq '.description = "'"$just"'"')

            tmpfile=$(mktemp)
            jq --argjson rule "$new_rule" '.auto_firewall_rules += [$rule]' "$new_file" > "$tmpfile"
            mv "$tmpfile" "$new_file"

            touched_files["$new_file"]=1

          done < update_instructions.txt

          # Delete any file from updated dir if it's now empty
          for f in firewall-requests-updated/*.auto.tfvars.json; do
            if [ -f "$f" ]; then
              rulecount=$(jq '.auto_firewall_rules | length' "$f")
              if [ "$rulecount" -eq 0 ]; then
                echo "Deleting now-empty rules file: $f"
                rm -f "$f"
              fi
            fi
          done

          # Copy all updated files back to main working dir
          cp firewall-requests-updated/*.auto.tfvars.json firewall-requests/ 2>/dev/null || true

          echo "=== FILES AFTER ==="
          ls -l firewall-requests/*.auto.tfvars.json || true
          for f in firewall-requests/*.auto.tfvars.json; do
            echo "----- $f -----"
            cat "$f"
          done

          # Export for PR step
          echo "REQID=$REQID" >> $GITHUB_ENV

      - name: ‚è´ Create or Update Pull Request for NetSec
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: |
            [Firewall Automation] Update/remove rules for ${{ env.REQID }}
          branch: firewall/${{ env.REQID }}-update-${{ github.event.issue.number }}
          title: "Firewall update/removal: ${{ env.REQID }} (Issue #${{ github.event.issue.number }})"
          body: |
            Automated firewall rule update/removal for REQID `${{ env.REQID }}`.

            **Summary:**
            - Source: ${{ github.event.issue.user.login }}
            - Related Issue: #${{ github.event.issue.number }}

            **Rules:**  
            _See the file `firewall-requests/${{ env.REQID }}.auto.tfvars.json` for full details._

            > **NetSec:** Please review and merge if approved.  
          add-paths: |
            firewall-requests/*.auto.tfvars.json
          base: main

      - name: üí¨ Comment PR Link to Issue
        if: steps.cpr.outputs.pull-request-url != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `:robot: PR [#${{ steps.cpr.outputs.pull-request-number }}](${{ steps.cpr.outputs.pull-request-url }}) opened/updated for NetSec review.`
            })

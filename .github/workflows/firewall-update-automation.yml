name: üîÑ Process Firewall Rule Update/Removal Requests

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    if: contains(github.event.issue.labels.*.name, 'firewall-update-request')
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üìù Parse Issue and Update/Move/Remove Rules
        id: process
        shell: bash
        run: |
          set -e
          set -x

          # 1. Clean out any instructions between <!-- and -->
          ISSUE_BODY="${{ github.event.issue.body }}"
          ISSUE_BODY_CLEAN=$(echo "$ISSUE_BODY" | sed '/<!--/,/-->/d')

          echo "=== CLEANED ISSUE BODY ==="
          echo "$ISSUE_BODY_CLEAN"

          # 2. Parse out new REQID and CARID
          REQID=$(echo "$ISSUE_BODY_CLEAN" | grep -i "Request ID" | head -1 | cut -d: -f2- | xargs)
          CARID=$(echo "$ISSUE_BODY_CLEAN" | grep -i "CARID" | head -1 | cut -d: -f2- | xargs)
          echo "REQID: $REQID"
          echo "CARID: $CARID"
          if [ -z "$REQID" ]; then echo "REQID not found"; exit 1; fi
          if [ -z "$CARID" ]; then echo "CARID not found"; exit 1; fi

          # 3. Parse all rules robustly, one per block
          echo "$ISSUE_BODY_CLEAN" > body.txt
          awk '
            BEGIN { in_rule=0 }
            /^#### Rule/ { 
              if (in_rule) {
                print rulename "|" action "|" src "|" dst "|" ports "|" proto "|" dir "|" just
              }
              in_rule=1; rulename=action=src=dst=ports=proto=dir=just=""
              next
            }
            /^[[:space:]]*üîπ / {
              key=$0
              sub(/^[[:space:]]*üîπ /,"",key)
              idx=index(key,":")
              if(idx>0) {
                val=substr(key, idx+1)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
                label=substr(key, 1, idx-1)
                if(label=="Existing Rule Name") { rulename=val }
                else if(label=="Action") { action=val }
                else if(label ~ /^New Source/) { src=val }
                else if(label ~ /^New Destination/) { dst=val }
                else if(label ~ /^New Port/) { ports=val }
                else if(label ~ /^New Protocol/) { proto=val }
                else if(label ~ /^New Direction/) { dir=val }
                else if(label ~ /^New Business Justification/) { just=val }
              }
            }
            END {
              if (in_rule && rulename && action)
                print rulename "|" action "|" src "|" dst "|" ports "|" proto "|" dir "|" just
            }
          ' body.txt > update_instructions.txt

          echo "=== UPDATE INSTRUCTIONS ==="
          cat update_instructions.txt

          # 4. Copy every current rule file to updated dir, which is where all edits will happen
          mkdir -p firewall-requests-updated
          cp -r firewall-requests/* firewall-requests-updated/ 2>/dev/null || true

          # 5. Build lookup of rule -> file in the UPDATED directory!
          shopt -s nullglob
          declare -A rule_to_file
          find firewall-requests-updated -type f -name '*.auto.tfvars.json' | while read -r f; do
            while read -r rulename; do
              rule_to_file["$rulename"]="$f"
            done < <(jq -r '.auto_firewall_rules[].name' "$f")
          done

          # 6. Process instructions
          while IFS= read -r inst; do
            IFS='|' read -r existing_rulename action src dst ports proto dir just <<< "$inst"
            existing_rulename=$(echo "$existing_rulename" | xargs)
            action=$(echo "$action" | xargs)
            src=$(echo "$src" | xargs)
            dst=$(echo "$dst" | xargs)
            ports=$(echo "$ports" | xargs)
            proto=$(echo "$proto" | xargs)
            dir=$(echo "$dir" | xargs)
            just=$(echo "$just" | xargs)

            echo "---"
            echo "Processing: $existing_rulename | $action"

            old_file="${rule_to_file[$existing_rulename]}"
            if [ -z "$old_file" ]; then
              echo "Rule $existing_rulename not found in any file, skipping"
              continue
            fi

            # Remove from old file (always, even if moving/updating)
            jq 'del(.auto_firewall_rules[] | select(.name == "'"$existing_rulename"'"))' "$old_file" > "$old_file.tmp"
            mv "$old_file.tmp" "$old_file"

            if [ "$action" = "remove" ]; then
              echo "Removed $existing_rulename from $old_file"
              continue
            fi

            # Get the rule object from the original file
            orig_file="firewall-requests/$(basename "$old_file")"
            if [ ! -f "$orig_file" ]; then
              echo "Original file for $existing_rulename is missing ($orig_file). Skipping add."
              continue
            fi

            rule_obj=$(jq -c --arg name "$existing_rulename" '.auto_firewall_rules[] | select(.name==$name)' "$orig_file")
            if [ -z "$rule_obj" ]; then
              echo "Rule object not found for $existing_rulename in $orig_file"
              continue
            fi

            old_reqid=$(echo "$existing_rulename" | awk -F- '{print $2}')
            new_rulename="$existing_rulename"
            new_file="$old_file"

            if [ "$REQID" != "$old_reqid" ]; then
              # Update the rule name to the new REQID
              new_rulename=$(echo "$existing_rulename" | sed "s/$old_reqid/$REQID/")
              # Store under new path: oldreq/newreq.auto.tfvars.json
              dirpath=$(dirname "$old_file")
              mkdir -p "$dirpath/$REQID"
              new_file="$dirpath/$REQID/$REQID.auto.tfvars.json"
              # If the file does not exist, create an empty json array
              if [ ! -f "$new_file" ]; then
                echo '{"auto_firewall_rules": []}' > "$new_file"
              fi
            fi

            # Build updated rule object
            new_rule=$(echo "$rule_obj" | jq '.name = "'$new_rulename'"')
            [ -n "$src" ]   && new_rule=$(echo "$new_rule" | jq '.src_ip_ranges = ["'"$src"'"]')
            [ -n "$dst" ]   && new_rule=$(echo "$new_rule" | jq '.dest_ip_ranges = ["'"$dst"'"]')
            [ -n "$ports" ] && new_rule=$(echo "$new_rule" | jq '.ports = ["'"$ports"'"]')
            [ -n "$proto" ] && new_rule=$(echo "$new_rule" | jq '.protocol = "'"$proto"'"')
            [ -n "$dir" ]   && new_rule=$(echo "$new_rule" | jq '.direction = "'"$dir"'"')
            [ -n "$just" ]  && new_rule=$(echo "$new_rule" | jq '.description = "'"$just"'"')

            # Add updated rule to new file
            tmpfile=$(mktemp)
            jq --argjson rule "$new_rule" '.auto_firewall_rules += [$rule]' "$new_file" > "$tmpfile"
            mv "$tmpfile" "$new_file"

            # Refresh mapping for this rule
            rule_to_file["$new_rulename"]="$new_file"
          done < update_instructions.txt

          # 7. Delete any now-empty files
          find firewall-requests-updated -type f -name '*.auto.tfvars.json' | while read -r f; do
            rulecount=$(jq '.auto_firewall_rules | length' "$f")
            if [ "$rulecount" -eq 0 ]; then
              echo "Deleting now-empty rules file: $f"
              rm -f "$f"
            fi
          done

          # 8. Copy everything back
          cp -r firewall-requests-updated/* firewall-requests/ 2>/dev/null || true

          echo "=== FILES AFTER ==="
          find firewall-requests -type f -name '*.auto.tfvars.json' | while read -r f; do
            echo "----- $f -----"
            cat "$f"
          done

          # Export for PR step
          echo "REQID=$REQID" >> $GITHUB_ENV

      - name: ‚è´ Create or Update Pull Request for NetSec
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: |
            [Firewall Automation] Update/remove rules for ${{ env.REQID }}
          branch: firewall/${{ env.REQID }}-update-${{ github.event.issue.number }}
          title: "Firewall update/removal: ${{ env.REQID }} (Issue #${{ github.event.issue.number }})"
          body: |
            Automated firewall rule update/removal for REQID `${{ env.REQID }}`.

            **Summary:**
            - Source: ${{ github.event.issue.user.login }}
            - Related Issue: #${{ github.event.issue.number }}

            **Rules:**  
            _See the files for full details._

            > **NetSec:** Please review and merge if approved.  
          add-paths: |
            firewall-requests/**/*.auto.tfvars.json
          base: main

      - name: üí¨ Comment PR Link to Issue
        if: steps.cpr.outputs.pull-request-url != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `:robot: PR [#${{ steps.cpr.outputs.pull-request-number }}](${{ steps.cpr.outputs.pull-request-url }}) opened/updated for NetSec review.`
            })
